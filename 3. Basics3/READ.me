`npm`: `npm` stands for `Node Package Manager`. It is a tool that comes bundled with Node.js and helps manage packages, or modules. npm allows developers to install other people’s code packages into their own projects.

`Parcel/Webpack`: These are `bundlers` used mostly for JavaScript or TypeScript code that help you to minify, clean, and make your code compact so that it becomes easier to send a request or receive the response from the server when it usually takes you to transfer multiple files without using any bundler for loading the page.

`.parcel-cache`: The `.parcel-cache` folder (or .parcel-cache in parcel v2) stores information about your project when parcel builds it, so that when it rebuilds, it doesn’t have to re-parse and re-analyze everything from scratch.

`npx`: npx stands for `Node Package eXecute`. This command-line utility, bundled with npm version 5.2.0 and above, allows developers to execute Node.js packages directly from the npm registry without globally installing them on your system.

`dependencies vs devDependencies`: `dependencies` are packages that your project needs to run, while `devDependencies` are packages that are only needed during development and testing.

`Transitive Dependency`: A `transitive dependency` is an indirect dependency relationship between software components. This kind of dependency is held by virtue of a transitive relation from a component that the software depends on directly.

`Tree Shaking`: `Tree shaking` refers to `dead code elimination`. It means that unused modules will not be included in the bundle during the build process.

`Hot Module Replacement (HMR)`: HMR is a feature offered by tools like Webpack that allows all kinds of modules to be updated at runtime without the need for a full refresh.

/**************\*\*\***************/

`Superpowers of Parcel`: Some of the superpowers of Parcel include:
`Zero Configuration`: Parcel requires minimal to no configuration to get started.

`Fast Build Algorithm`: Parcel features a superfast build algorithm that reduces build times significantly.

`Hot Module Replacement`: Parcel supports Hot Module Replacement (HMR), which gives you quick feedback as you edit your code without needing to reload the page.

`Image Optimization`: Parcel automatically optimizes images to reduce their file size without losing quality.

`Caching`: Parcel implements caching during development to speed up rebuilds by reusing previous outputs.

/************\*\*\*************/

`.gitignore`: A `.gitignore` file is a text file placed in your git repository that tells git not to track certain files and folders that you don’t want being uploaded to your master repository.

`package.json vs package-lock.json`: While `package.json` sets the boundaries for what versions of packages your project can use, `package-lock.json` goes a step further by locking in the exact versions of every package, including their dependencies.

`Modifying package-lock.json`: You should not modify package-lock.json because it is auto-generated and provides a detailed, deterministic record of the dependency tree.

`node_modules`: `node_modules` is a directory in your project where npm installs your dependencies. It is not a good idea to push this directory to git because it can become very large, and you can always recreate it by running npm install.

`dist folder`: In a React project, the dist directory, short for “distribution”, is typically generated by your build tool and contains the compiled version of your application.

`browserlists`: `Browserslist` is a config to share target browsers and Node.js versions between different front-end tools. It is used in tools like Autoprefixer, Stylelint, babel-preset-env, and others.

`^-caret and ~-tilde`: In package.json, a caret (^) before a version number means that updates that do not modify the left-most non-zero digit in the [major, minor, patch] tuple will be allowed. For example, ^1.2.3 will allow versions up to <2.0.0. A tilde (~) before a version number means that updates that do not modify the last digit in the [major, minor, patch] tuple will be allowed. For example, ~1.2.3 will allow versions up to <1.3.0.

`Script types in HTML`: In HTML, the type attribute in the 'script' tag is used to specify the scripting language for the script elements. The default value is “text/javascript”. Other possible values could be “module” for JavaScript modules, or “text/vbscript” for VBScript.
/************************************/
*Scripts in package.json :

Run Command:
- To npx our app, command is:
npx parcel index.html
- We always don’t have to write this command.
- Generally, we build a script, inside package.json which runs this commands in an easy way.

package.json : 

"scripts" : {
    "test" : "jest",
    "start" : "parcel index.html",
    "build" : "parcel build index.html"
},


Now, to run our project, we can use :
    `npm run start`   or   `npm start`

    instead of `npm parcel index.html`

to build our project, we can use :
    `npm run build`

    instead of `npm parcel build index.html`

/*************************************/

* Remove console logs automatically:
- Console logs are not removed automatically by parcel. You have to configure you projects to remove it.
- There is a package to remove console logs.
(Babel-plugin-transform-remove-console)

- Before installing the package, create a folder .babelrc and include :

{
    "plugins" : [["transform-remove-console", 
    {"exclude" : ["error", "warn"]}]]
}

- Then, build: npm run build
to see that all console logs are removed.

/*********************/
Reconciliation in React is the process by which React updates the browser DOM. It’s a key part of React’s efficiency and performance.

Here are some key points about reconciliation in React:

- `Virtual DOM`: React maintains a virtual DOM, which is a representation of the actual DOM. When state or props change, React re-renders the component, creating a new virtual DOM.

- `Diffing Algorithm`: React then compares the new virtual DOM with the old one using a process known as the "diffing algorithm". This process identifies the differences between the old and new virtual DOM.

- `DOM Update`: If differences are found, React updates only those parts of the actual DOM. For example, if only the attribute of an element changes, React will only update the attribute of the HTML element.

- `Efficiency`: React’s reconciliation process makes the DOM updates faster. It updates the virtual DOM first and then uses the diffing algorithm to make efficient and optimized updates in the real DOM.

- `Predictability`: The choices made in React’s “diffing” algorithm ensure that component updates are predictable while being fast enough for high-performance apps.

***Remember, reconciliation is a fundamental part of how React works. It’s the reason why React is able to efficiently update and render components.

/*************************************/

In React, `rendering` is the process of generating a description of what the user interface should look like based on the application’s current state and props

/**************************************/

`Rules for react reconciliation`

React’s reconciliation process follows certain rules to efficiently update the UI. Here are the key rules:

- Element Type: If the root elements of the old and new trees are of different types, React will tear down the old tree and build the new tree from scratch. For example, going from <a> to <img>, or from <Article> to <Comment>, or from <Button> to <div> - any of those will lead to a full rebuild.

- DOM Elements of the Same Type: When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes.

- Component Elements of the Same Type: When a component updates, React updates the props of the component and re-renders the component.

- Recursing On Children: By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference.

- Keys: React uses the key attribute to match children in the original tree with children in the subsequent tree. Keys should be stable, predictable, and unique for each sibling, so React can maintain the component state and reorder elements instead of re-creating them. ***If we have multiple children, we should use keys to make our code more faster.

Remember, the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same1. Just because a component is rendered, doesn’t mean React will unmount and remount them. It will only apply the differences following the rules stated above.


/*************************************/

* Babel:
- It is a javascript package / library used to convert code written in newer versions of JS (ECMAScript 2015, 2016, 2017 etc) into code that can be run in older JS Engines.

/**************************************/

jsx stands for `javascript xml`, which has html-like syntax

Our browser does not understand jsx.
Using Babel, jsx is converted to React.createElement().

Jsx -> React.createElement() -> Object -> HTML Dom


Advantages of JSX:
- Developer Experience
- Syntactical Sugar
- Readibilty
- Less code
- Maintainability
- No Repitition


*** Babel comes alongwith parcel

/****************************************/